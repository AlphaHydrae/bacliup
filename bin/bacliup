#!/usr/bin/env bash
set -e

function build_rclone_command() {
  local subcommand="$1"
  shift

  local rclone_cmd=("$rclone_bin")
  test -n "$rclone_config_file" && rclone_cmd+=(--config "$rclone_config_file")
  rclone_cmd+=("$subcommand" $@)

  echo "${rclone_cmd[@]}"
}

function create_temporary_directory() {
  if is_macos; then
    mktemp -d -t bacliup
  else
    mktemp -d -t bacliup.XXXXXX
  fi
}

function check_gpg_recipient_available() {
  local recipient="$1"
  test -n "$("$gpg_bin" --armor --batch --export "$1" 2>/dev/null)"
}

function check_rclone_remote_available() {
  local remote="$1"
  local rclone_cmd=($(build_rclone_command listremotes))
  local available_remotes=("$("${rclone_cmd[@]}")")
  element_in_array "${remote}:" "${available_remotes[@]}"
}

function element_in_array() {
  local element="$1"
  shift

  for current_value in "$@"; do
    if [[ "$current_value" == "$element" ]]; then
      return 0
    fi
  done

  return 1
}

function fail() {
  >&2 echo "$@"
  exit 1
}

function get_config_value() {
  local type="$1"
  local key="$2"

  local path="${backup_configs_dir}/${type}"
  test -f "$path" || return 0

  cat "$path" | \
    grep "^${key} " | \
    tail -n 1 | \
    sed "s/^${key} //"
}

function get_rclone_remote_from_path() {
  local path="$1"
  echo "$path" | sed 's/:.*//'
}

function is_macos() {
  local operating_system_name="$(uname -s | tr '[:upper:]' '[:lower:]')"
  [[ "$operating_system_name" == "darwin" ]]
}

function list_configs() {
  if test -d "$backup_configs_dir"; then
    ls -1 "$backup_configs_dir"
  fi
}

function local_cleanup() {
  local tmp_dir="$1"
  test -d "$tmp_dir" && rm -fr "$tmp_dir"
}



# Features
# ========

function back_up() {
  if test "$#" -ge 1; then
    backup_type="$1"
    shift
  fi

  test "$#" -eq 0 || fail "Extra positional argument(s) not supported by 'backup' subcommand: $@"

  local backup_timestamp="$(date -u "+%Y%m%dT%H%M%SZ")"
  local backup_directory_name="${backup_name}.${backup_timestamp}"
  local current_backup_dir="${tmp_dir}/${backup_directory_name}"
  local current_backup_basename="${backup_directory_name}.tar.gpg"

  mkdir "$current_backup_dir"

  BACKUP_DIR="$current_backup_dir" "$backup_script"

  local tar_cmd=("$tar_bin" -C "$(dirname "$current_backup_dir")" -cf - "$(basename "$current_backup_dir")")

  local gpg_cmd=("$gpg_bin" "--armor" "--batch" "--encrypt")
  for recipient in "${gpg_recipients[@]}"; do
    check_gpg_recipient_available "$recipient" || \
      fail "GPG recipient '${recipient}' cannot be found. Is the GPG key in the keyring?"

    gpg_cmd+=("--recipient" "$recipient")
  done

  local rclone_remote="$(get_rclone_remote_from_path "$backup_to")"
  test -n "$rclone_remote" || fail "Backup destination ${backup_to} must be an rclone path specifying a remote, e.g. 'dest:path'"
  check_rclone_remote_available "$rclone_remote" || fail "Backup remote $rclone_remote cannot be found. Is it defined in the rclone configuration file?"
  local rclone_dest="${backup_to%/}/${current_backup_basename}"
  local rclone_cmd=($(build_rclone_command rcat "$rclone_dest"))

  local raw_size_file="${tmp_dir}/raw-size.pv"
  local final_size_file="${tmp_dir}/final-size.pv"
  local now="$(date "+%s")"

  "${tar_cmd[@]}" | \
    "${gpg_cmd[@]}" | \
    pv -bf 2>"$final_size_file" | \
    "${rclone_cmd[@]}"

  local backup_size="$(cat "$final_size_file" | tr -cd '[:alnum:]._-')"
  local now_after="$(date "+%s")"
  local elapsed_seconds="$(($now_after-$now))"

  if test -n "$slack_webhook"; then
    local backup_message="Successful"
    test -n "$backup_type" && backup_message="$backup_message $backup_type"
    backup_message="$backup_message backup for $backup_name"

    local backup_duration="${elapsed_seconds}s"
    test "$elapsed_seconds" -eq 0 && backup_duration="< 1s"

    cat "${templates_dir}/slack-success.json" | \
      backup_message="$backup_message" backup_name="$backup_name" backup_type="$backup_type" backup_duration="$backup_duration" backup_size="\`${backup_size}\`" backup_destination="\`${rclone_dest}\`" envsubst | \
      "$curl_bin" \
        --data-binary @- \
        -H "Content-Type: application/json" \
        "$slack_webhook"
  fi
}

function generate_backup_cron() {
  test "$#" -gt 0 && fail "Extra positional argument(s) not supported by 'cron' subcommand: $@"

  local cron="$(cat <<EOF
# ┌───────────── minute (0 - 59)
# │ ┌───────────── hour (0 - 23)
# │ │ ┌───────────── day of the month (1 - 31)
# │ │ │ ┌───────────── month (1 - 12)
# │ │ │ │ ┌───────────── day of the week (0 - 6) (Sunday to Saturday;
# │ │ │ │ │                                   7 is also Sunday on some systems)
# │ │ │ │ │
# │ │ │ │ │
# * * * * * <command to execute>
EOF
)"

  for backup_config in "$(list_configs)"; do
    cron_schedule="$(get_config_value "$backup_config" cron)"
    cron="$(printf "${cron}\n\n${cron_schedule} /usr/local/bin/bacliup $backup_config &>/dev/stdout\n")"
  done

  echo "$cron"
}



# Parse options
# =============

# Environment
script_path="$( cd -- "$(dirname "$0")" >/dev/null 2>&1; pwd -P )"

# Binaries
curl_bin="${BACLIUP_CURL_BIN:-curl}"
gpg_bin="${BACLIUP_GPG_BIN:-gpg}"
rclone_bin="${BACLIUP_RCLONE_BIN:-rclone}"
tar_bin="${BACLIUP_TAR_BIN:-tar}"

# Backup options
backup_type="${BACLIUP_BACKUP_TYPE:-default}"
backup_name="${BACLIUP_BACKUP_NAME:-backup}"
backup_configs_dir="${BACLIUP_BACKUP_CONFIGS_DIR:-/etc/bacliup/backups}"
backup_script="${BACLIUP_BACKUP_SCRIPT:-/usr/local/bin/backup}"
backup_to="${BACLIUP_BACKUP_TO:-"dest:"}"
IFS=',' read -r -a gpg_recipients <<< "$BACLIUP_GPG_RECIPIENT"
gpg_cli_recipients=()

# Storage options
rclone_config_file="${BACLIUP_RCLONE_CONFIG_FILE}"

# Notification options
slack_webhook="$BACLIUP_SLACK_WEBHOOK"

# Other options
templates_dir="${BACLIUP_TEMPLATES_DIR:-"${script_path}/../templates"}"

positional_args=()

while [[ $# -gt 0 ]]; do
  case "$1" in
    -r|--gpg-recipient)
      gpg_cli_recipients+=("$2")
      shift
      shift
    ;;
    -s|--script)
      backup_script="$2"
      shift
      shift
    ;;
    -t|--to)
      backup_to="$2"
      shift
      shift
    ;;
    --)
      shift
      remaining_args=($@)
      positional_args+=("${remaining_args[@]}")
      break
    ;;
    -*|--*)
      echo "Unknown option $1"
      exit 1
    ;;
    *)
      positional_args+=("$1")
      shift
    ;;
  esac
done

# Restore positional parameters.
set -- "${positional_args[@]}"

# Override environment variables with command-line arguments.
test "${#gpg_cli_recipients[@]}" -ge 1 && gpg_recipients=("${gpg_cli_recipients[@]}")

action="backup"
if [[ "$1" == "backup" ]]; then
  shift
elif [[ "$1" == "cron" ]]; then
  action="cron"
  shift
fi

backup_to="$(get_config_value "to")"
backup_to="${backup_to:-${BACLIUP_BACKUP_TO:-dest:}}"

tmp_dir=`create_temporary_directory`
trap "local_cleanup $tmp_dir" EXIT

log_file="${tmp_dir}/bacliup.log"
touch "$log_file"
exec &> >(tee -a "$log_file")

if [[ "$action" == "backup" ]]; then
  back_up "$@"
elif [[ "$action" == "cron" ]]; then
  generate_backup_cron "$@"
fi
