#!/usr/bin/env bash
set -e

function build_rclone_command() {
  local subcommand="$1"
  shift

  local rclone_cmd=("$rclone_bin")
  test -n "$rclone_config_file" && rclone_cmd+=(--config "$rclone_config_file")
  rclone_cmd+=("$subcommand" $@)

  echo "${rclone_cmd[@]}"
}

function create_temporary_directory() {
  if is_macos; then
    mktemp -d -t bacliup
  else
    mktemp -d -t bacliup.XXXXXX
  fi
}

function check_gpg_recipient_available() {
  local recipient="$1"
  test -n "$("$gpg_bin" --armor --batch --export "$1" 2>/dev/null)"
}

function check_rclone_remote_available() {
  local remote="$1"
  local rclone_cmd=($(build_rclone_command listremotes))
  local available_remotes=("$("${rclone_cmd[@]}")")
  element_in_array "${remote}:" "${available_remotes[@]}"
}

function element_in_array() {
  local element="$1"
  shift

  for current_value in "$@"; do
    if [[ "$current_value" == "$element" ]]; then
      return 0
    fi
  done

  return 1
}

function fail() {
  local code="$1"
  shift
  >&2 echo "$@"
  exit $code
}

function get_config_value() {
  local type="$1"
  local key="$2"

  local path="${backup_configs_dir}/${type}"
  test -f "$path" || return 0

  cat "$path" | \
    grep "^${key} " | \
    tail -n 1 | \
    sed "s/^${key} //"
}

function get_rclone_remote_from_path() {
  local path="$1"
  echo "$path" | sed 's/:.*//'
}

function is_macos() {
  local operating_system_name="$(uname -s | tr '[:upper:]' '[:lower:]')"
  [[ "$operating_system_name" == "darwin" ]]
}

function list_configs() {
  if test -d "$backup_configs_dir"; then
    ls -1 "$backup_configs_dir"
  fi
}

function local_cleanup() {
  local tmp_dir="$1"
  test -d "$tmp_dir" && rm -fr "$tmp_dir"
}

function slack_success() {
  local backup_name="$1"
  local backup_type="$2"
  local backup_duration="$3"
  local backup_size="$4"
  local backup_destination="$5"

  test -n "$slack_webhook" || return 0

  local backup_message=":white_check_mark: Successful"
  test -n "$backup_type" && backup_message="$backup_message $backup_type"
  backup_message="$backup_message backup for $backup_name"

  local backup_duration="${elapsed_seconds}s"
  test "$elapsed_seconds" -eq 0 && backup_duration="< 1s"

  cat "${templates_dir}/slack-success.json" | \
    jq --arg backup_message "$backup_message" '(.attachments[0].title) |= $backup_message' | \
    jq --arg backup_name "$backup_name" '(.attachments[0].fields[] | select(.title == "Backup") | .value) |= $backup_name' | \
    jq --arg backup_type "$backup_type" '(.attachments[0].fields[] | select(.title == "Type") | .value) |= $backup_type' | \
    jq --arg backup_duration "$backup_duration" '(.attachments[0].fields[] | select(.title == "Duration") | .value) |= $backup_duration' | \
    jq --arg backup_size "\`$backup_size\`" '(.attachments[0].fields[] | select(.title == "Size") | .value) |= $backup_size' | \
    jq --arg backup_destination "\`$backup_destination\`" '(.attachments[0].fields[] | select(.title == "Destination") | .value) |= $backup_destination' | \
    "$curl_bin" --data-binary @- -H "Content-Type: application/json" "$slack_webhook"
}



# Features
# ========

function back_up() {
  if test "$#" -ge 1; then
    backup_type="$1"
    shift
  fi

  test "$#" -eq 0 || fail 4 "Extra positional argument(s) not supported by 'backup' subcommand: $@"
  test -e "$backup_script" || fail 100 "Backup script ${backup_script} does not exist"
  test -f "$backup_script" || fail 101 "Backup script ${backup_script} is not a file"
  test -x "$backup_script" || fail 102 "Backup script ${backup_script} is not executable"

  local backup_to_from_config="$(get_config_value "$backup_type" "to")"
  local backup_to="${BACLIUP_BACKUP_TO:-${backup_to_from_config:-dest:}}"
  backup_to="$(printf "$backup_to" | backup_name="$backup_name" backup_type="$backup_type" envsubst '$backup_name $backup_type')"

  local backup_timestamp="$(date -u "+%Y%m%dT%H%M%SZ")"
  local backup_directory_name="${backup_name}.${backup_timestamp}"
  local current_backup_dir="${tmp_dir}/${backup_directory_name}"
  local current_backup_basename="${backup_directory_name}.tar.gpg"

  mkdir "$current_backup_dir"
  cd "$current_backup_dir"

  echo '@@@@@@@@@@@@@@@@@@@'
  echo "tmp directory: $tmp_dir"
  echo "current backup dir: $current_backup_dir"
  ls -la "$current_backup_dir"
  echo '@@@@@@@@@@@@@@@@@@@ backup script permissions'
  ls -l "$backup_script"
  echo '@@@@@@@@@@@@@@@@@@@ backup script contents'
  cat "$backup_script"
  echo '@@@@@@@@@@@@@@@@@@@'

  BACKUP_DIR="$current_backup_dir" "$backup_script"

  echo '@@@@@@@@@@@@@@@@@@@ backup file contents'
  cat "$current_backup_dir/hello.txt"
  echo '@@@@@@@@@@@@@@@@@@@'
  exit 1
  echo '@@@@@@@@@@@@@@@@@@@'

  local tar_cmd=("$tar_bin" -C "$(dirname "$current_backup_dir")" -cf - "$(basename "$current_backup_dir")")

  local gpg_cmd=("$gpg_bin" "--armor" "--batch" "--encrypt")
  for recipient in "${backup_gpg_recipients[@]}"; do
    check_gpg_recipient_available "$recipient" || \
      fail 140 "GPG recipient '${recipient}' cannot be found. Is the GPG key in the keyring?"

    gpg_cmd+=("--recipient" "$recipient")
  done

  local rclone_remote="$(get_rclone_remote_from_path "$backup_to")"
  test -n "$rclone_remote" || fail 160 "Backup destination ${backup_to} must be an rclone path specifying a remote, e.g. 'dest:path'"
  check_rclone_remote_available "$rclone_remote" || fail 161 "Backup remote $rclone_remote cannot be found. Is it defined in the rclone configuration file?"
  local rclone_dest="${backup_to%/}/${current_backup_basename}"
  local rclone_cmd=($(build_rclone_command rcat "$rclone_dest"))

  local final_size_file="${tmp_dir}/final-size.pv"
  local now="$(date "+%s")"

  echo "Backing up..."
  echo "  ${tar_cmd[@]} | \\"
  echo "  ${gpg_cmd[@]} | \\"
  echo "  ${rclone_cmd[@]}"

  "${tar_cmd[@]}" | \
    "${gpg_cmd[@]}" | \
    pv -bf 2>"$final_size_file" | \
    "${rclone_cmd[@]}"

  local backup_size="$(cat "$final_size_file" | tr -cd '[:alnum:]._-')"
  local now_after="$(date "+%s")"
  local elapsed_seconds="$(($now_after-$now))"

  slack_success "$backup_name" "$backup_type" "$backup_duration" "$backup_size" "$rclone_dest"
}

function generate_backup_cron() {
  local cron="$(cat <<EOF
# ┌───────────── minute (0 - 59)
# │ ┌───────────── hour (0 - 23)
# │ │ ┌───────────── day of the month (1 - 31)
# │ │ │ ┌───────────── month (1 - 12)
# │ │ │ │ ┌───────────── day of the week (0 - 6) (Sunday to Saturday;
# │ │ │ │ │                                   7 is also Sunday on some systems)
# │ │ │ │ │
# │ │ │ │ │
# * * * * * <command to execute>
EOF
)"

  for backup_config in "$(list_configs)"; do
    cron_schedule="$(get_config_value "$backup_config" cron)"
    cron="$(printf "${cron}\n\n${cron_schedule} bacliup ${cron_script} ${backup_config} &>/dev/stdout\n")"
  done

  echo "$cron"
}

function import_gpg_key() {
  test -n "$gpg_import_key" || return 0

  echo "$gpg_import_key" | gpg --batch --import || fail 141 "Could not import GPG key"

  if test -n "$gpg_import_key_id"; then
    echo "${gpg_import_key_id}:6:" > "${tmp_dir}/gpg-ownertrust"
    gpg --import-ownertrust "${tmp_dir}/gpg-ownertrust" || fail 142 "Could not configure GPG ownertrust"
  fi
}

function init() {
  test "$#" -gt 0 && fail 4 "Extra positional argument(s) not supported by 'init' subcommand: $@"

  import_gpg_key

  echo "$(generate_backup_cron)" | crontab -
}



# Parse options
# =============

# Environment
script_path="$( cd -- "$(dirname "$0")" >/dev/null 2>&1; pwd -P )"

# Binaries
curl_bin="${BACLIUP_CURL_BIN:-curl}"
gpg_bin="${BACLIUP_GPG_BIN:-gpg}"
rclone_bin="${BACLIUP_RCLONE_BIN:-rclone}"
tar_bin="${BACLIUP_TAR_BIN:-tar}"

# Backup options
backup_type="${BACLIUP_BACKUP_TYPE:-default}"
backup_name="${BACLIUP_BACKUP_NAME:-backup}"
backup_configs_dir="${BACLIUP_BACKUP_CONFIGS_DIR:-/etc/bacliup/backups}"
backup_script="${BACLIUP_BACKUP_SCRIPT:-/usr/local/bin/backup}"
backup_to="${BACLIUP_BACKUP_TO:-"dest:"}"

# Encryption options
gpg_import_key="$BACLIUP_GPG_IMPORT_KEY"
gpg_import_key_id="$BACLIUP_GPG_IMPORT_KEY_ID"
IFS=',' read -r -a backup_gpg_recipients <<< "$BACLIUP_GPG_RECIPIENT"
backup_gpg_cli_recipients=()

# Cron options
cron_script="${BACLIUP_CRON_SCRIPT:-/usr/local/bin/bacliup}"

# Storage options
rclone_config_file="${BACLIUP_RCLONE_CONFIG_FILE}"

# Notification options
slack_webhook="$BACLIUP_SLACK_WEBHOOK"

# Other options
templates_dir="${BACLIUP_TEMPLATES_DIR:-"${script_path}/../templates"}"

positional_args=()

while [[ $# -gt 0 ]]; do
  case "$1" in
    -r|--gpg-recipient)
      backup_gpg_cli_recipients+=("$2")
      shift
      shift
    ;;
    -s|--script)
      backup_script="$2"
      shift
      shift
    ;;
    -t|--to)
      backup_to="$2"
      shift
      shift
    ;;
    --)
      shift
      remaining_args=($@)
      positional_args+=("${remaining_args[@]}")
      break
    ;;
    -*|--*)
      echo "Unknown option $1"
      exit 1
    ;;
    *)
      positional_args+=("$1")
      shift
    ;;
  esac
done

# Restore positional parameters.
set -- "${positional_args[@]}"

# Override environment variables with command-line arguments.
test "${#backup_gpg_cli_recipients[@]}" -ge 1 && backup_gpg_recipients=("${backup_gpg_cli_recipients[@]}")

action="backup"
if [[ "$1" == "backup" ]]; then
  shift
elif [[ "$1" == "init" ]]; then
  action="init"
  shift
fi

tmp_dir=`create_temporary_directory`
trap "local_cleanup $tmp_dir" EXIT

if [[ "$action" == "backup" ]]; then
  back_up "$@"
elif [[ "$action" == "init" ]]; then
  init "$@"
fi
